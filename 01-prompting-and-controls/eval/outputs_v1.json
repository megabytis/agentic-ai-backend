[
  {
    "task": "Write a Python function that takes a list of numbers and returns the sum of all even numbers in the list.",
    "output": "```python\ndef sum_even_numbers(numbers_list):\n  \"\"\"\n  Calculates the sum of all even numbers in a given list of numbers.\n\n  Args:\n    numbers_list: A list of integers or floating-point numbers.\n\n  Returns:\n    The sum of all even numbers found in the list. Returns 0 if no even numbers\n    are present or if the list is empty.\n  \"\"\"\n  total_even_sum = 0\n  for number in numbers_list:\n    # Check if the number is even.\n    # We use number % 2 == 0. This works for both positive and negative\n    # integers. For floats, it will essentially treat numbers like 4.0 as even\n    # and 3.5 as odd (as 3.5 % 2 would not be 0).\n    if number % 2 == 0:\n      total_even_sum += number\n  return total_even_sum\n\n# --- Examples ---\nif __name__ == \"__main__\":\n  list1 = [1, 2, 3, 4, 5, 6]\n  print(f\"List: {list1}\")\n  print(f\"Sum of even numbers: {sum_even_numbers(list1)}\") # Expected: 2 + 4 + 6 = 12\n\n  list2 = [10, 20, 30, 41, 52]\n  print(f\"\\nList: {list2}\")\n  print(f\"Sum of even numbers: {sum_even_numbers(list2)}\") # Expected: 10 + 20 + 30 + 52 = 112\n\n  list3 = [1, 3, 5, 7, 9]\n  print(f\"\\nList: {list3}\")\n  print(f\"Sum of even numbers: {sum_even_numbers(list3)}\") # Expected: 0 (no even numbers)\n\n  list4 = []\n  print(f\"\\nList: {list4}\")\n  print(f\"Sum of even numbers: {sum_even_numbers(list4)}\") # Expected: 0 (empty list)\n\n  list5 = [-2, -5, 0, 8]\n  print(f\"\\nList: {list5}\")\n  print(f\"Sum of even numbers: {sum_even_numbers(list5)}\") # Expected: -2 + 0 + 8 = 6\n\n  list6 = [1.0, 2.0, 3.5, 4.0, 5] # Example with floats and integers\n  print(f\"\\nList: {list6}\")\n  print(f\"Sum of even numbers: {sum_even_numbers(list6)}\") # Expected: 2.0 + 4.0 = 6.0\n```",
    "score": 10
  },
  {
    "task": "Generate a JSON configuration for a web server with the following settings: port 8080, enable SSL, and set the root directory to '/var/www/html'.",
    "output": "```json\n{\n  \"server_settings\": {\n    \"port\": 8080,\n    \"ssl_enabled\": true,\n    \"root_directory\": \"/var/www/html\"\n  }\n}\n```",
    "score": 10
  },
  {
    "task": "Create a regular expression to match email addresses.",
    "output": "Matching email addresses with a regular expression is a classic computer science problem, but it's deceptively complex. A truly *fully RFC-compliant* regex is extremely long, difficult to read, and can suffer from catastrophic backtracking, making it unsuitable for most practical applications.\n\nInstead, the common approach is to use a regex that covers the vast majority of valid email addresses encountered in practice, while being robust enough to reject most invalid ones.\n\nHere are a few options, ranging from common and practical to more comprehensive:\n\n---\n\n### Option 1: Common and Practical (Recommended for most uses)\n\nThis regex is widely used for its balance of readability, performance, and coverage of typical email formats.\n\n```regex\n^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\n```\n\n**Explanation of Components:**\n\n*   `^`: Asserts the start of the string.\n*   `[a-zA-Z0-9._%+-]+`: Matches the **local part** (the part before `@`).\n    *   `a-zA-Z0-9`: Allows letters (both uppercase and lowercase) and digits.\n    *   `._%+-`: Allows dot, underscore, percent, plus, and hyphen characters.\n    *   `+`: Means one or more of the preceding characters.\n*   `@`: Matches the literal \"@\" symbol.\n*   `[a-zA-Z0-9.-]+`: Matches the **domain part** (the part between \"@\" and the last dot).\n    *   `a-zA-Z0-9`: Allows letters and digits.\n    *   `.-`: Allows dot and hyphen characters.\n    *   `+`: Means one or more of the preceding characters.\n*   `\\.`: Matches a literal dot (the dot before the Top-Level Domain). It's escaped with a backslash because `.` has a special meaning (any character) in regex.\n*   `[a-zA-Z]{2,}`: Matches the **Top-Level Domain (TLD)**.\n    *   `a-zA-Z`: Allows letters (e.g., \"com\", \"org\", \"net\", \"co.uk\").\n    *   `{2,}`: Specifies that the TLD must be at least 2 characters long (e.g., \"us\", \"uk\", \"io\"). Many TLDs are 3+ characters, and new ones can be much longer, so `{2,}` is generally good.\n*   `$`: Asserts the end of the string.\n\n**Matches:**\n\n*   `john.doe@example.com`\n*   `jane_doe123@sub.domain.co.uk`\n*   `user+alias@mail.net`\n*   `test-email@my-company.org`\n\n**Does NOT Match (and usually correctly so for practical purposes):**\n\n*   `user@localhost` (lacks a TLD)\n*   `user@.com` (domain starts with a dot)\n*   `user@example` (lacks a TLD)\n*   `john..doe@example.com` (local part has consecutive dots - this regex allows it due to `._%+-+` but many stricter regexes would not. For most practical uses, this is usually acceptable, as real email providers generally disallow it anyway.)\n*   `user@example-.com` (domain ends with a hyphen)\n\n---\n\n### Option 2: More Comprehensive (closer to HTML5 validation, still practical)\n\nThis version is a bit stricter, especially regarding the structure of the domain labels, which prevents patterns like `example-.com` or `example..com`. It also allows a slightly wider range of special characters in the local part, as per common email practices.\n\n```regex\n^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*(?:\\.[a-zA-Z]{2,63})$\n```\n\n**Key Differences / Explanation:**\n\n*   **Local Part:** `[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+`\n    *   Includes more special characters common in email local parts, defined by RFCs (excluding `\"` and `\\` which would require quoted strings, and whitespace).\n*   **Domain Part Structure:**\n    *   `(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)`: This pattern describes a single \"label\" in the domain name (e.g., `example`, `sub`, `co`).\n        *   `[a-zA-Z0-9]`: Starts with an alphanumeric character.\n        *   `(?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?`: Optionally allows 0 to 61 alphanumeric characters or hyphens, *followed by* an alphanumeric character. This ensures labels don't start or end with a hyphen.\n    *   `(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*`: Allows zero or more additional labels (like `sub.domain`).\n    *   `(?:\\.[a-zA-Z]{2,63})$`: The final TLD.\n        *   `[a-zA-Z]{2,63}`: Ensures the TLD is 2 to 63 letters long. This covers current TLDs, including long ones (e.g., `.photography`).\n\n---\n\n### Important Considerations:\n\n1.  **Case-Insensitivity:** Email domains are case-insensitive. If your regex engine supports flags, you should typically use the case-insensitive flag (e.g., `i` in JavaScript, Python `re.IGNORECASE`).\n    *   Example in Python: `re.match(r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\", email, re.IGNORECASE)`\n\n2.  **RFC Compliance vs. Practicality:**\n    *   The RFCs (like RFC 5322 and RFC 6854) allow for *very* complex email addresses, including quoted strings, comments, and IP addresses as domains (e.g., `\"john.doe\"@example.com`, `user@[192.168.1.1]`).\n    *   A regex that strictly follows the RFCs is extraordinarily complex and rarely used in practice because it's hard to maintain and can have performance issues. The provided regexes handle 99.9% of real-world valid email addresses.\n    *   For the extreme edge cases, it's often better to rely on actual email delivery (sending a confirmation email) rather than trying to perfectly validate with regex.\n\n3.  **Client-Side vs. Server-Side Validation:**\n    *   **Client-side:** Use a good, practical regex (like Option 1 or 2) for immediate feedback to the user.\n    *   **Server-side:** *Always* re-validate on the server. The server-side validation should also use a robust regex, but for critical applications, consider more advanced techniques like verifying the domain's MX records to ensure it can actually receive mail (though this doesn't guarantee the *user* exists).\n\n4.  **Length Limits:** These regexes don't enforce overall email length limits (e.g., 254 characters as per RFC). You might need to add separate checks for that.\n\n---\n\n**Which one to choose?**\n\n*   For most web forms and general-purpose validation, **Option 1** is perfectly adequate and easiest to read and debug.\n*   If you need slightly stricter domain validation and want to allow a broader set of characters in the local part without going full RFC, **Option 2** is a good choice.",
    "score": 10
  }
]