[
  {
    "task": "Generate Python code to calculate the factorial of a given non-negative integer.",
    "output": "```python\ndef calculate_factorial(n):\n  \"\"\"\n  Calculates the factorial of a non-negative integer.\n\n  Args:\n    n: A non-negative integer.\n\n  Returns:\n    The factorial of n (n!).\n\n  Raises:\n    ValueError: If the input n is a negative integer.\n  \"\"\"\n  if not isinstance(n, int) or n < 0:\n    raise ValueError(\"Input must be a non-negative integer.\")\n\n  if n == 0:\n    return 1  # Factorial of 0 is 1\n  else:\n    # Initialize factorial to 1\n    factorial = 1\n    # Iterate from 1 up to n and multiply\n    for i in range(1, n + 1):\n      factorial *= i\n    return factorial\n\n# --- Example Usage ---\n\n# Get input from the user\ntry:\n  num = int(input(\"Enter a non-negative integer to calculate its factorial: \"))\n\n  # Calculate and print the factorial\n  result = calculate_factorial(num)\n  print(f\"The factorial of {num} is {result}\")\n\nexcept ValueError as e:\n  print(f\"Error: {e}\")\nexcept Exception as e:\n  print(f\"An unexpected error occurred: {e}\")\n\n# --- Another example with a hardcoded value ---\n# try:\n#   hardcoded_num = 5\n#   result_hardcoded = calculate_factorial(hardcoded_num)\n#   print(f\"The factorial of {hardcoded_num} is {result_hardcoded}\")\n# except ValueError as e:\n#   print(f\"Error: {e}\")\n```\n\n**Explanation:**\n\n1. **`calculate_factorial(n)` function:**\n   - **Input Validation:**\n     - `if not isinstance(n, int) or n < 0:`: This line checks if the input `n` is an integer and if it's non-negative.\n     - `isinstance(n, int)`: Checks if `n` is of the integer type.\n     - `n < 0`: Checks if `n` is less than zero.\n     - `raise ValueError(\"Input must be a non-negative integer.\")`: If the input is invalid, a `ValueError` is raised with a descriptive message. This is good practice for indicating that the function received incorrect input.\n\n   - **Base Case:**\n     - `if n == 0:`: The factorial of 0 is defined as 1. This is the base case for the factorial calculation.\n     - `return 1`: Returns 1 immediately if `n` is 0.\n\n   - **Iterative Calculation:**\n     - `else:`: If `n` is greater than 0, the factorial is calculated iteratively.\n     - `factorial = 1`: Initializes a variable `factorial` to 1. This is important because we'll be multiplying numbers into it.\n     - `for i in range(1, n + 1):`: This loop iterates through numbers from 1 up to and including `n`.\n       - `range(1, n + 1)` generates a sequence of numbers: 1, 2, 3, ..., `n`.\n     - `factorial *= i`: In each iteration, the current value of `factorial` is multiplied by the loop variable `i`. This effectively calculates `1 * 2 * 3 * ... * n`.\n     - `return factorial`: After the loop finishes, the calculated `factorial` is returned.\n\n2. **Example Usage:**\n   - **Getting User Input:**\n     - `try...except ValueError`: This block handles potential errors if the user enters something that cannot be converted to an integer.\n     - `num = int(input(\"Enter a non-negative integer to calculate its factorial: \"))`: Prompts the user to enter a number and converts it to an integer.\n   - **Calculating and Printing:**\n     - `result = calculate_factorial(num)`: Calls the `calculate_factorial` function with the user's input.\n     - `print(f\"The factorial of {num} is {result}\")`: Prints the result in a user-friendly format using an f-string.\n   - **Handling Other Exceptions:**\n     - `except Exception as e:`: This is a general exception handler that catches any other unexpected errors that might occur.\n\n**Alternative (Recursive) Approach (for educational purposes):**\n\nYou can also calculate factorials recursively. Here's how:\n\n```python\ndef calculate_factorial_recursive(n):\n  \"\"\"\n  Calculates the factorial of a non-negative integer using recursion.\n\n  Args:\n    n: A non-negative integer.\n\n  Returns:\n    The factorial of n (n!).\n\n  Raises:\n    ValueError: If the input n is a negative integer.\n  \"\"\"\n  if not isinstance(n, int) or n < 0:\n    raise ValueError(\"Input must be a non-negative integer.\")\n\n  if n == 0:\n    return 1\n  else:\n    return n * calculate_factorial_recursive(n - 1)\n\n# Example Usage for recursive function\n# try:\n#   num_rec = int(input(\"Enter a non-negative integer (recursive): \"))\n#   result_rec = calculate_factorial_recursive(num_rec)\n#   print(f\"The factorial of {num_rec} (recursive) is {result_rec}\")\n# except ValueError as e:\n#   print(f\"Error: {e}\")\n```\n\n**Key differences in the recursive approach:**\n\n- **Base Case:** `if n == 0: return 1` remains the same.\n- **Recursive Step:** `else: return n * calculate_factorial_recursive(n - 1)`: The function calls itself with a smaller value of `n` (`n - 1`) and multiplies the result by `n`. This continues until the base case (`n == 0`) is reached.\n\nWhile both iterative and recursive approaches are valid, the iterative approach is generally preferred for calculating factorials in Python due to its better performance and avoidance of potential stack overflow issues for very large numbers.",
    "score": 10
  },
  {
    "task": "Create a JSON configuration object for a web server, including port, hostname, and logging settings.",
    "output": "```json\n{\n  \"server\": {\n    \"port\": 8080,\n    \"hostname\": \"localhost\",\n    \"ssl_enabled\": false,\n    \"ssl_certificate\": null,\n    \"ssl_key\": null\n  },\n  \"logging\": {\n    \"level\": \"info\",\n    \"file\": \"/var/log/webserver/access.log\",\n    \"max_file_size_mb\": 100,\n    \"max_files\": 5,\n    \"log_format\": \"[%Y-%m-%d %H:%M:%S] [%level] %message\"\n  },\n  \"routes\": [\n    {\n      \"path\": \"/\",\n      \"handler\": \"static\",\n      \"options\": {\n        \"directory\": \"./public\"\n      }\n    },\n    {\n      \"path\": \"/api/users\",\n      \"handler\": \"api\",\n      \"options\": {\n        \"endpoint\": \"users\",\n        \"methods\": [\"GET\", \"POST\"]\n      }\n    }\n  ]\n}\n```\n\n**Explanation of the JSON Configuration:**\n\nThis JSON object provides a comprehensive configuration for a web server. Let's break down each section:\n\n**`server` Object:**\n\n*   **`port` (number):** The network port on which the web server will listen for incoming connections. Common values include 80 (for HTTP) and 443 (for HTTPS). Here, it's set to `8080` for development or non-standard usage.\n*   **`hostname` (string):** The hostname or IP address the server will bind to. `localhost` means it will only be accessible from the same machine. You might use `0.0.0.0` to listen on all available network interfaces.\n*   **`ssl_enabled` (boolean):** A flag to indicate whether SSL/TLS is enabled for secure connections. `false` means HTTPS is not configured.\n*   **`ssl_certificate` (string or null):** The path to the SSL certificate file (e.g., `.crt` or `.pem`). This is `null` if `ssl_enabled` is `false`.\n*   **`ssl_key` (string or null):** The path to the SSL private key file (e.g., `.key`). This is `null` if `ssl_enabled` is `false`.\n\n**`logging` Object:**\n\n*   **`level` (string):** The minimum severity level of messages to be logged. Common levels include:\n    *   `debug`: Very detailed information, useful for development.\n    *   `info`: General operational information.\n    *   `warn`: Potential issues that don't necessarily stop the application.\n    *   `error`: Critical errors that may cause partial or complete failure.\n    *   `fatal`: Very severe errors that will likely cause the application to crash.\n    Here, it's set to `info`.\n*   **`file` (string):** The absolute or relative path to the file where log messages will be written.\n*   **`max_file_size_mb` (number):** The maximum size (in megabytes) a log file can reach before it's rotated.\n*   **`max_files` (number):** The maximum number of rotated log files to keep. Older files will be deleted.\n*   **`log_format` (string):** A template string defining the format of each log entry. Common placeholders include:\n    *   `%Y-%m-%d`: Year-Month-Day\n    *   `%H:%M:%S`: Hour:Minute:Second\n    *   `%level`: The logging level (e.g., `info`, `error`).\n    *   `%message`: The actual log message.\n\n**`routes` Array:**\n\nThis section defines how the server handles different URL paths. It's an array of route objects.\n\n*   **`path` (string):** The URL path that this route will match.\n*   **`handler` (string):** The type of handler to use for this route. Examples could be:\n    *   `static`: Serve static files from a directory.\n    *   `api`: Handle API requests, potentially forwarding to a backend service.\n    *   `render`: Render a view or template.\n*   **`options` (object):** Configuration specific to the chosen `handler`.\n    *   For `static` handler:\n        *   `directory` (string): The root directory from which to serve static files.\n    *   For `api` handler:\n        *   `endpoint` (string): The specific API endpoint name or identifier.\n        *   `methods` (array of strings): The HTTP methods (e.g., `GET`, `POST`, `PUT`, `DELETE`) that this route will respond to.\n\n**How to Use This Configuration:**\n\nA web server application would typically:\n\n1.  **Read this JSON file** from the file system.\n2.  **Parse the JSON string** into a JavaScript object (or its equivalent in other languages).\n3.  **Use the parsed data** to configure its settings (port, hostname, logging, route handlers, etc.).\n\nThis JSON format makes it easy to manage and modify server settings without changing the server's core code.",
    "score": 10
  },
  {
    "task": "Write a regular expression to validate an email address.",
    "output": "Okay, here's a regular expression that's widely used and generally considered good for validating email addresses, along with an explanation.\n\n**The Regular Expression:**\n\n```regex\n^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\n```\n\n**Explanation of the Components:**\n\n*   `^`: **Start of the string.** This ensures the pattern matches from the very beginning of the input.\n\n*   `[a-zA-Z0-9._%+-]+`: **The local part (username).**\n    *   `[a-zA-Z0-9._%+-]`: This character set defines what characters are allowed in the local part.\n        *   `a-zA-Z`: Uppercase and lowercase English letters.\n        *   `0-9`: Digits.\n        *   `._%+-`: The characters period (`.`), underscore (`_`), percent (`%`), plus (`+`), and hyphen (`-`). These are commonly allowed in email usernames.\n    *   `+`: **One or more times.** This means the local part must have at least one character.\n\n*   `@`: **The \"at\" symbol.** This is a mandatory separator between the local part and the domain part.\n\n*   `[a-zA-Z0-9.-]+`: **The domain name (excluding the TLD).**\n    *   `[a-zA-Z0-9.-]`: This character set defines what characters are allowed in the domain name.\n        *   `a-zA-Z`: Uppercase and lowercase English letters.\n        *   `0-9`: Digits.\n        *   `.-`: The characters period (`.`) and hyphen (`-`). Hyphens cannot be at the beginning or end of a domain label, but this regex doesn't explicitly check that for simplicity.\n    *   `+`: **One or more times.** The domain name must have at least one character.\n\n*   `\\.`: **A literal dot.** This separates the domain name from the Top-Level Domain (TLD). The backslash `\\` escapes the dot, so it's treated as a literal character and not as \"any character.\"\n\n*   `[a-zA-Z]{2,}`: **The Top-Level Domain (TLD).**\n    *   `[a-zA-Z]`: Allows only uppercase and lowercase English letters.\n    *   `{2,}`: **Two or more times.** This means the TLD must be at least two characters long (e.g., `.com`, `.org`, `.uk`, `.info`).\n\n*   `$`: **End of the string.** This ensures the pattern matches to the very end of the input.\n\n**Why This Regex is Generally Good (and its limitations):**\n\n**Pros:**\n\n*   **Covers most common email formats:** It will validate the vast majority of email addresses you'll encounter in everyday use.\n*   **Relatively easy to understand:** The components are fairly straightforward.\n*   **Practical:** It's often a good balance between strictness and usability.\n\n**Cons (and why perfect validation is impossible with regex alone):**\n\n*   **RFC 5322 is extremely complex:** The official standard for email address syntax (RFC 5322) is incredibly intricate and allows for many unusual formats that are rarely, if ever, used in practice. A regex to perfectly match *all* valid RFC 5322 addresses would be astronomically long, unreadable, and impractical for most applications.\n    *   For example, RFC 5322 allows quoted strings in the local part, comments, and IP addresses in brackets in the domain part.\n*   **Doesn't check for domain existence:** This regex can't tell you if the domain actually exists or if there's a mail server to receive emails.\n*   **Doesn't check for deliverability:** It won't tell you if the email address is actually active.\n*   **Internationalized Domain Names (IDNs):** This regex doesn't account for non-ASCII characters in domain names (e.g., `b\u00fccher.de`). For those, you'd need a more complex regex or different validation methods.\n*   **Specific character restrictions:** While it allows common characters, some very specific rules (like hyphens not at the start/end of domain labels) are not enforced.\n\n**In most practical scenarios, this regex provides a very good level of validation.** For truly robust validation, you would typically:\n\n1.  **Use this regex for a first-pass check.**\n2.  **Send a confirmation email to the address** to verify its existence and deliverability.\n\n**Example Usage (in Python):**\n\n```python\nimport re\n\nemail_regex = r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n\ndef is_valid_email(email):\n  if re.match(email_regex, email):\n    return True\n  else:\n    return False\n\nprint(is_valid_email(\"test.email+alias@example.com\"))   # True\nprint(is_valid_email(\"invalid-email@.com\"))            # False (domain starts with dot)\nprint(is_valid_email(\"another_email@sub.domain.co.uk\")) # True\nprint(is_valid_email(\"no-at-sign.com\"))               # False\nprint(is_valid_email(\"short@d.c\"))                      # False (TLD too short)\nprint(is_valid_email(\"very.long.email.address.with.many.dots@and.very.long.domain.name.example.com\")) # True\n```",
    "score": 10
  }
]